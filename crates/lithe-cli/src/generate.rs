use crate::server::{self, ClientFunction, ServerFunction};
use anyhow::{Context, Result};
use regex::Regex;
use std::fs;
use std::path::Path;

#[derive(Debug)]
pub struct PageRoute {
    pub route: String,
    pub module_name: String,
    pub file_path: String,
    pub name: String,
    pub full_mod_path: String,
}

pub fn discover_pages(project_dir: &Path, crate_name: &str) -> Result<Vec<PageRoute>> {
    let pages_dir = project_dir.join("src/pages");
    let mut pages = Vec::new();
    if !pages_dir.exists() {
        return Ok(pages);
    }

    scan_pages_recursive(&pages_dir, &pages_dir, project_dir, crate_name, &mut pages)?;

    pages.sort_by(|a, b| {
        if a.route == "/" {
            std::cmp::Ordering::Less
        } else if b.route == "/" {
            std::cmp::Ordering::Greater
        } else {
            a.route.cmp(&b.route)
        }
    });
    Ok(pages)
}

fn scan_pages_recursive(
    dir: &Path,
    pages_root: &Path,
    project_root: &Path,
    crate_name: &str,
    pages: &mut Vec<PageRoute>,
) -> Result<()> {
    let page_re = Regex::new(r#"#\[(?:[\w:]+::)?page\]"#).unwrap();
    let crate_name_clean = crate_name.replace('-', "_");

    for entry in fs::read_dir(dir).context(format!("Failed to read directory: {:?}", dir))? {
        let entry = entry?;
        let path = entry.path();
        if path.is_dir() {
            scan_pages_recursive(&path, pages_root, project_root, crate_name, pages)?;
        } else if path.extension().map_or(false, |ext| ext == "rs") {
            let file_stem = path.file_stem().unwrap().to_str().unwrap().to_string();
            if file_stem == "mod" {
                continue;
            }

            let content = fs::read_to_string(&path).unwrap_or_default();
            if !page_re.is_match(&content) {
                continue;
            }

            let relative_from_src = path.strip_prefix(project_root.join("src"))?;

            // Logic must match server::scan_file and generate_lib_rs_content
            let mod_name = relative_from_src
                .with_extension("")
                .to_string_lossy()
                .replace(['/', '\\'], "_");

            let full_mod_path = format!("{}::{}", crate_name_clean, mod_name);

            // Calculate route (URL path)
            let rel_from_pages = path.strip_prefix(pages_root)?;
            let mut route_segments = Vec::new();
            for segment in rel_from_pages.parent().unwrap().components() {
                route_segments.push(segment.as_os_str().to_str().unwrap().replace('_', "-"));
            }
            if file_stem != "index" {
                route_segments.push(file_stem.replace('_', "-"));
            }
            let route = format!("/{}", route_segments.join("/")).replace("//", "/");

            let relative_path = format!("../src/{}", relative_from_src.to_string_lossy());

            pages.push(PageRoute {
                route,
                module_name: mod_name,
                file_path: relative_path,
                name: file_stem,
                full_mod_path,
            });
        }
    }
    Ok(())
}

pub fn generate_routes_content(
    pages: &[PageRoute],
    project_name: &str,
    client_fns: &[ClientFunction],
    server_fns: &[ServerFunction],
) -> String {
    let mut output = String::new();
    output.push_str("// Auto-generated by lithe-cli - do not edit manually\n");
    output.push_str("use lithe::render_page;\n\n");
    let crate_name = project_name.replace('-', "_");

    for page in pages {
        output.push_str(&format!("#[path = \"{}\"]\n", page.file_path));
        output.push_str(&format!("mod {};\n", page.module_name));
    }
    output.push_str("\npub fn dispatch(path: &str) -> String {\n");
    output.push_str("    match path {\n");

    for page in pages {
        let mut map = std::collections::HashMap::new();

        for f in client_fns {
            let path_key = f.full_path.replace("::", "_");
            map.insert(
                format!("h_{}", server::hash_id_raw(&path_key)),
                f.hashed_id.clone(),
            );

            if f.full_path.starts_with(&page.full_mod_path)
                && f.full_path.len() > page.full_mod_path.len()
            {
                let local_name = &f.full_path[page.full_mod_path.len() + 2..];
                map.insert(
                    format!("h_{}", server::hash_id_raw(local_name)),
                    f.hashed_id.clone(),
                );
            }
        }

        for f in server_fns {
            let path_key = f.full_path.replace("::", "_");
            map.insert(
                format!("h_{}", server::hash_id_raw(&path_key)),
                f.hashed_id.clone(),
            );

            if f.full_path.starts_with(&page.full_mod_path)
                && f.full_path.len() > page.full_mod_path.len()
            {
                let local_name = &f.full_path[page.full_mod_path.len() + 2..];
                map.insert(
                    format!("h_{}", server::hash_id_raw(local_name)),
                    f.hashed_id.clone(),
                );
            }
        }

        let map_json = serde_json::to_string(&map).unwrap();

        output.push_str(&format!(
            "        \"{}\" => render_page({}::page(), \"{}\", {:?}),\n",
            page.route, page.module_name, crate_name, map_json
        ));
    }
    output.push_str("        _ => \"404 Not Found\".to_string(),\n");
    output.push_str("    }\n");
    output.push_str("}\n");

    output.push_str("\npub fn routes() -> Vec<&'static str> {\n");
    output.push_str("    vec![");
    let routes: Vec<String> = pages.iter().map(|p| format!("\"{}\"", p.route)).collect();
    output.push_str(&routes.join(", "));
    output.push_str("]\n");
    output.push_str("}\n");
    output
}

pub fn generate_main_content(port: u16) -> String {
    format!(
        r#"// Auto-generated by lithe-cli - do not edit manually
use axum::{{Router, extract::Path, response::{{Html, IntoResponse, Response}}, routing::{{get, post}}, body::Body, http::{{header, StatusCode}}}};
use rust_embed::RustEmbed;
#[path = "routes.rs"]
mod routes;
#[path = "rpc.rs"]
mod rpc;

#[derive(RustEmbed)]
#[folder = ".lithe/public/"]
struct Assets;

async fn handle_root() -> Html<String> {{
    Html(routes::dispatch("/"))
}}

async fn handle_path(Path(path): Path<String>) -> Html<String> {{
    Html(routes::dispatch(&format!("/{{}}", path)))
}}

async fn static_handler(Path(path): Path<String>) -> impl IntoResponse {{
    let path = path.trim_start_matches('/');
    if let Some(content) = Assets::get(path) {{
        let mime = mime_guess::from_path(path).first_or_octet_stream();
        Response::builder()
            .header(header::CONTENT_TYPE, mime.as_ref())
            .body(Body::from(content.data))
            .unwrap()
    }} else {{
        Response::builder()
            .status(StatusCode::NOT_FOUND)
            .body(Body::from("404 Not Found"))
            .unwrap()
    }}
}}

#[tokio::main]
async fn main() {{
    let app = Router::new()
        .route("/api/lithe-rpc", post(rpc::handle_rpc))
        .route("/public/*path", get(static_handler))
        .route("/", get(handle_root))
        .route("/*path", get(handle_path));
    let listener = tokio::net::TcpListener::bind("0.0.0.0:{port}").await.unwrap();
    println!("Listening on http://localhost:{port}");
    axum::serve(listener, app).await.unwrap();
}}
"#,
        port = port
    )
}

pub fn discover_modules(project_dir: &Path, crate_name: &str) -> Result<Vec<(String, String)>> {
    let src_dir = project_dir.join("src");
    let mut modules = Vec::new();
    if !src_dir.exists() {
        return Ok(modules);
    }

    scan_modules_recursive(&src_dir, &src_dir, crate_name, &mut modules)?;

    Ok(modules)
}

fn scan_modules_recursive(
    dir: &Path,
    src_root: &Path,
    crate_name: &str,
    modules: &mut Vec<(String, String)>,
) -> Result<()> {
    for entry in fs::read_dir(dir).context("Failed to read src directory")? {
        let entry = entry?;
        let path = entry.path();
        if path.is_dir() {
            let dir_name = path.file_name().unwrap().to_str().unwrap();
            if dir_name == "public" {
                continue;
            }
            scan_modules_recursive(&path, src_root, crate_name, modules)?;
        } else if path.extension().map_or(false, |ext| ext == "rs") {
            let file_stem = path.file_stem().unwrap().to_str().unwrap().to_string();
            if file_stem == "lib" || file_stem == "main" || file_stem == "mod" {
                continue;
            }

            let relative = path.strip_prefix(src_root)?;
            let mod_name = relative
                .with_extension("")
                .to_string_lossy()
                .replace(['/', '\\'], "_");
            let rel_path = format!("../src/{}", relative.to_string_lossy());

            modules.push((mod_name, rel_path));
        }
    }
    Ok(())
}

pub fn generate_lib_rs_content(pages: &[PageRoute], modules: &[(String, String)]) -> String {
    let mut output = String::new();
    output.push_str("// Auto-generated by lithe-cli - do not edit manually\n\n");

    for (name, path) in modules {
        output.push_str(&format!("#[path = \"{}\"]\n", path));
        output.push_str(&format!("pub mod {};\n\n", name));
    }

    for page in pages {
        // Skip if already added as module
        if modules.iter().any(|(n, _)| n == &page.module_name) {
            continue;
        }
        output.push_str(&format!("#[path = \"{}\"]\n", page.file_path));
        output.push_str(&format!("pub mod {};\n\n", page.module_name));
    }

    output.push_str("pub mod pages {\n");
    for page in pages {
        output.push_str(&format!(
            "    pub use super::{} as {};\n",
            page.module_name, page.name
        ));
    }
    output.push_str("}\n\n");

    output.push_str("#[cfg(target_arch = \"wasm32\")]\n");
    output.push_str("#[path = \"wasm_exports.rs\"]\n");
    output.push_str("mod wasm_exports;\n");

    output
}

pub fn generate_all(project_dir: &Path, port: u16) -> Result<()> {
    let lithe_dir = project_dir.join(".lithe");
    fs::create_dir_all(&lithe_dir).context("Failed to create .lithe directory")?;
    let cargo_toml_path = project_dir.join("Cargo.toml");
    let cargo_toml_content = fs::read_to_string(&cargo_toml_path)?;
    let project_name = cargo_toml_content
        .lines()
        .find(|l| l.starts_with("name = "))
        .map(|l| l.split('=').nth(1).unwrap().trim().trim_matches('"'))
        .unwrap_or("app");

    let pages = discover_pages(project_dir, project_name)?;
    let modules = discover_modules(project_dir, project_name)?;
    let (client_fns, server_fns) = server::discover_functions(project_dir, project_name)?;

    server::generate_rpc_dispatcher(project_dir, project_name, &server_fns)?;
    server::generate_wasm_exports(project_dir, project_name, &client_fns, &server_fns)?;

    let routes_content = generate_routes_content(&pages, project_name, &client_fns, &server_fns);
    fs::write(lithe_dir.join("routes.rs"), routes_content)
        .context("Failed to write .lithe/routes.rs")?;

    let main_content = generate_main_content(port);
    fs::write(lithe_dir.join("main.rs"), main_content).context("Failed to write .lithe/main.rs")?;

    let lib_content = generate_lib_rs_content(&pages, &modules);
    fs::write(lithe_dir.join("lib.rs"), lib_content).context("Failed to write .lithe/lib.rs")?;

    Ok(())
}
